# Integration tests

The other main piece of code generated by `anchor init` is the integration
tests. These tests can be written in typescript or javascript (chosen by our
`--typescript` tag when calling `anchor init`).

We can run `anchor test` to run our tests.

Let's take a look at `./tests/first-program.ts`

```js
import * as anchor from "@project-serum/anchor";

describe("first-program", () => {
  // Configure the client to use the local cluster.
  anchor.setProvider(anchor.Provider.env());

  it("Is initialized!", async () => {
    // Add your test here.
    const program = anchor.workspace.FirstProgram;
    const tx = await program.rpc.initialize();
    console.log("Your transaction signature", tx);
  });
});
```

First, we import anchor and define a test block. We then set up anchor to use
the local provider.

Anchor has a "workspace" feature which will load in the IDL at runtime and
provide us with tooling to interact with our program. Then, we can do the exact
same call we did in the client, `await program.rpc.initialize();`

{% hint style="warning" %} `anchor.workspace.FirstProgram` is loaded into the
test environment for us. Changing the program can generate a different IDL that
wouldn't be represented here. Be careful when making changes to the name of your
program module and make sure the tests represent that.

Also, the workspace feature is currently only available within the context of
`anchor test`. Don't use this one in your frontend code. {% endhint %}

The test framework here gives you more flexibility to specify different account
ids programmatically, and make sure that you're always starting with fresh state
on each test run. We'll be using this tool to help us iterate quickly on our
Anchor programs throughout this book.
